<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connor Huh</title>
  <link rel="stylesheet" href="/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
  <script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
  <nav>
    <div class="nav-brand">Connor Huh</div>
  
    <div class="nav-right">
      <ul class="navbar">
        <li><a href="/">Home</a></li>
        <li><a href="/projects">Projects</a></li>
      </ul>
  
      <label class="theme-switch" for="mode-toggle">
        <input type="checkbox" id="mode-toggle" />
        <span class="slider"></span>
        <span class="emoji sun">‚òÄÔ∏è</span>
        <span class="emoji moon">üåô</span>
      </label>
    </div>
  </nav>
  <header>
    <h1>Pricing Foreign Exchange Barrier Options via Stochastic Simulation</h1>
  </header>
</body>
  <main>
    <div class="content">
      <h2>Preface</h2>
      <p>
      This paper grew out of a longer-standing interest I‚Äôve had in using simulation to solve problems where closed-form solutions break down. I‚Äôd studied European option pricing before, but barrier options seemed like a natural next step‚Äîtechnically richer, more sensitive to model structure, and deeply rooted in practical finance.
      </p>
      
      <p>
      My goal was to understand the complications of pricing path-dependent derivatives and experiment with methods that mitigate the well-known challenges of simulating rare path behavior. I wanted to implement everything from scratch‚Äîmodel, paths, controls, even variance reduction‚Äîboth to understand how they work and to explore the limits of pure simulation.
      </p>
      
      <h2>Modeling the FX Rate</h2>
      <p>
      To simulate barrier options in an FX setting, I modeled the spot rate \( S_t \) under two stochastic processes. First, I implemented the classical geometric Brownian motion (GBM) model, which assumes constant volatility and continuous compounding ‚Äî the standard in Black-Scholes-Merton-style approaches. Then, to better account for empirical volatility clustering and smile/skew effects in FX markets, I extended the simulation to incorporate the Heston model, which introduces a stochastic variance component following its own mean-reverting CIR process.
      </p>
      
      <img src="gbm-paths.png" alt="Sample paths under GBM" style="max-width:100%; margin: 1.2rem 0 0.4rem 0; border: 2px solid #ccc; border-radius: 12px;" />
      <p class="caption">
      Sample paths of the FX spot rate under geometric Brownian motion used in Monte Carlo simulation.
      </p>
      
      <p>
      Using Monte Carlo simulation, I generated thousands of synthetic price paths and computed expected payoffs. However, simulating barrier options na√Øvely introduces significant variance and discretization bias, especially when monitoring is discrete (e.g. daily or hourly).
      </p>
      
      <h2>Variance Reduction</h2>

      <p>
      After building out the core simulation framework, I quickly ran into a familiar issue: noise. Even after thousands of paths, the option values bounced around more than I expected. This wasn‚Äôt surprising ‚Äî pricing barrier options via Monte Carlo is notoriously variance-heavy due to their path-dependence and discontinuity. But it was clear I needed to rein in the randomness if I wanted results that were meaningful.
      </p>
      
      <p>
      I looked into variance reduction strategies. Antithetic variates felt like an obvious first step: for each simulated path, I mirrored its Brownian motion with a negatively correlated twin. This alone helped tighten the confidence intervals. But I also began thinking about discretization. A major subtlety with barrier options is that you might miss a barrier breach if your monitoring isn‚Äôt continuous ‚Äî and this is especially problematic in naive simulations.
      </p>
      
      <p>
      To fix this, I implemented <strong>Brownian bridge interpolation</strong>, which estimates the likelihood of the barrier being breached between discrete time steps. Conceptually, it "fills in the gaps" in each path, which makes the simulation more robust. For example, two paths that appear to survive might, when interpolated, reveal that they likely crossed the barrier after all. Penalizing these paths creates a far more realistic valuation. This step made a big difference ‚Äî not just numerically, but in how much I trusted the model‚Äôs output.
      </p>
      <figure>
        <img src="brownian_bridge.png" alt="Brownian bridge adjustment visualization" style="max-width:100%; border-radius: 10px; margin: 2rem 0;" />
        <figcaption style="font-size: 0.95rem; text-align: center; margin-top: 0.5rem;">
          Two FX paths (dashed) that survive discrete monitoring yet likely breach the barrier when interpolated. Brownian bridge adjustment penalizes these cases.
        </figcaption>
      </figure>
      
      <h2>Results</h2>
      
      <p>
      Once everything was in place, I ran a variety of experiments across both <em>knock-in</em> and <em>knock-out</em> options under different volatilities, interest rate spreads, and barrier levels. I started with the geometric Brownian motion (GBM) model and compared those results to the more nuanced <strong>Heston model</strong> with stochastic volatility.
      </p>
      
      <p>
      What I noticed was that the barrier‚Äôs relative distance from the current spot price had a huge influence ‚Äî almost more so than the volatility itself. When the barrier was set just outside the likely range of the simulated paths, small changes in volatility or monitoring frequency could cause large shifts in the payoff probability.
      </p>
      
      <p>
      The Heston model produced more realistic values in many of these edge cases. That said, it was harder to control and less analytically tractable. It felt a bit like working with a temperamental artist: capable of brilliance, but much harder to predict.
      </p>
      
      <p>
      Even with good variance reduction, these simulations are never going to be ultra-precise. But I wasn‚Äôt trying to publish ‚Äî I was trying to understand. And for that goal, the numbers were good enough.
      </p>

      
      <h2>Reflection</h2>
      <p>
      This project was a test of both my modeling intuition and coding precision. Writing a pricing engine from scratch‚Äîone that balanced theoretical rigor with practical speed‚Äîwasn‚Äôt easy. But I walked away with a stronger sense of how real-world derivatives get priced, and why the simplest models often hide the deepest challenges.
      </p>
      
      <p>
      Going forward, I‚Äôd like to explore real-time pricing APIs, calibrate the Heston model to historical data, and maybe even try pricing American-style barrier options.
      </p>

    
    <p>
    If you're interested in the full implementation, feel free to check out the code repository and notebook breakdown.
    </p>
    </div>
  </main>
  <footer>
    ¬© 2025 Connor Huh. All rights reserved.
  </footer>
  <!-- JS scroll behavior -->
  <script>
    let lastScrollY = window.scrollY;
    const nav = document.querySelector('nav');
  
    window.addEventListener('scroll', () => {
      const currentScrollY = window.scrollY;
      if (currentScrollY > lastScrollY && currentScrollY > 50) {
        nav.classList.add('hidden');
      } else {
        nav.classList.remove('hidden');
      }
      lastScrollY = currentScrollY;
    });
  
    // Dark mode toggle
    const modeToggle = document.getElementById("mode-toggle");
    const body = document.body;
  
    // On load, set toggle position to current theme
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      body.classList.add('dark');
      modeToggle.checked = true;
    } else {
      body.classList.remove('dark');
      modeToggle.checked = false;
    }
  
    modeToggle.addEventListener("change", function () {
      if (this.checked) {
        body.classList.add('dark');
        localStorage.setItem('theme', 'dark');
      } else {
        body.classList.remove('dark');
        localStorage.setItem('theme', 'light');
      }
    });
  </script>
</body>
</html>
