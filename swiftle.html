<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connor Huh</title>
  <link rel="stylesheet" href="/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</head>
<body>
  <nav>
    <div class="nav-brand">Connor Huh</div>
  
    <div class="nav-right">
      <ul class="navbar">
        <li><a href="/">Home</a></li>
        <li><a href="/projects">Projects</a></li>
        <li><a href="/about">About</a></li>
      </ul>
  
      <label class="theme-switch">
        <span class="emoji">ðŸŒž</span>
        <input type="checkbox" id="mode-toggle" />
        <span class="slider"></span>
        <span class="emoji">ðŸŒ™</span>
      </label>
    </div>
  </nav>
  <header>
    <h1>Beating Swiftle with Python and PyAutoGUI</h1>
    <p>07-25-2025</p>
  </header>
</body>
</html>
  <main>
    <div class="content">
      <h2>Introduction</h2>
      <p>If you know anything about me, you probably know I've listened to my fair share of Taylor Swift. In 2023 alone, I accumulated over 1100 hours of her music on Spotify, contributing to more than 80% of my total listening time. Over 250 of these hours were spent solely listening to <em>All Too Well (10 Minute Version) (Taylor's Version)</em>. This level of commitment landed me in the top 0.01% of Taylor Swift listeners globally. I was even able to see her perform live during the <em>Era's Tour</em> earlier that year.</p>
  
      <p>My obsession with Swift's music began through imitation. Growing up, I always looked up to my sister, whose interests were my blueprint. When she became enchanted by Taylor Swift, I followed suit. By eighth grade, many knowledge of her songs became a sort of social currency, and many of my friendships stemmed from a shared love for her music. It even led to a Taylor Swift-centric group chat that persists today, despite my switching schools for ninth grade.</p>
      
      <p>Given this, you'd expect me to be good at <a href="https://www.techyonic.co/swiftle/rapid" target="_blank">Swiftle Rapid</a>, a game that requires users to correctly identify the title of a Taylor Swift song snippet in ten seconds or less. But strangely enough, I'm awful at it. Often, I recognize the melody, but my mind becomes a blank space when grasping for its title. Other times, I'm unfamiliar with the song entirely. Though I've listened to her entire catalog before, my listening habits are heavily skewed toward my favorites, leaving a vast number of tracks almost untouched. I know the lyrics to many of her songs by heart; it's just not always the right ones. While some of my friends have streaks well into the triple digits, it took me multiple tries just to break a streak of five.</p>
  
      <p>Not exactly a great look for a top 0.01% Taylor Swift fan...</p>
  
      <p>Ever since I learned how dreadful I was at this game, I've dreamed of writing a program that could beat the game for me. Over the past few days, I finally brought my wildest dream to life.</p>
  
      <p>The pipeline was conceptually simple:</p>
      <ol>
        <li>Capture the audio snippet from Swiftle.</li>
        <li>Use a music recognition API to identify the song.</li>
        <li>Click the search bar, type the answer, and hit Enter.</li>
      </ol>
  
      <p>I hoped to automate the process entirely, meaning I could let the script run in the background without monitoring it.</p>

      
      <h2>Build</h2>
  
      <p>Despite the apparent simplicity of the idea, actually building it involved a decent amount of debugging and domain-specific adjustments. I knew it would rely significantly on external packages, most of which I have no knowledge of. Thus, a large portion of my preliminary work was searching for packages online that could contribute to my script.</p>
  
      <p>The first step was to figure out how to record the Swiftle audio snippet automatically. I used sounddevice to capture audio from my computer. To capture internal audio on my MacBook, I installed a virtual input device called BlackHole. After selecting the correct device index in Python, I was ready to record.</p>
  
      <pre><code class="language-python">def record_audio(filename='snippet.wav'):
    recording = sd.rec(int(DURATION * FS), samplerate=FS, channels=2, device=DEVICE_INDEX)
    sd.wait()
    write(filename, FS, recording)</code></pre>
  
      <p>I opted to record the browser audio for 2.5 seconds, which proved to be enough time for the script to recognize the song. While a prolonged time would theoretically increase the chances of accurately identifying the song, it left less time for the script to process everything and enter the answer.</p>
  
      <p>Once I had the audio, the next step was to identify the song. I used <a href="https://audd.io/" target="_blank">Audd.io</a>, a simple but surprisingly powerful API for music recognition. The interface is pretty clean: you post the file, include your API token, and get a JSON response with the song metadata (if recognized). I had it return the Spotify data as well, just in case, though I didnâ€™t end up needing it.</p>
  
      <pre><code class="language-python">def identify_song(filename='snippet.wav'):
    with open(filename, 'rb') as f:
        files = {'file': f}
        data = {'api_token': API_TOKEN, 'return': 'spotify'}
        response = requests.post('https://api.audd.io/', data=data, files=files)
    result = response.json()
    return result['result'].get('title', '').strip()</code></pre>
  
      <p>Audio recognition APIs, as it turns out, are surprisingly sensitive: if a file is even slightly too short, too long, or noisy, the software often proves futile. Fortunately, Audd.io did well, recognizing snippets from any part of even the most obscure Taylor Swift vault tracks.</p>

      
      <h2>Answer Submission</h2>
  
      <p>Swiftle doesn't have an API, and I didn't want to even attempt to reverse-engineer its frontend. So instead, I opted to use brute-force automation. The script needed to move the mouse to the search bar coordinates on my screen, click down, type the name of the song, and press Enter to submit. To determine the location of the search bar on my computer, I ran a separate program using PyAutoGUI. Once executed, the program waits three seconds for me to hover my cursor over Swiftle's search bar before printing the cursor's coordinates. Though I was unfamiliar with the package at the start of this project, it turned out to be straightforward.</p>
  
      <pre><code class="language-python">time.sleep(3)
x, y = pyautogui.position()
print(x, y)</code></pre>
  
      <p>I also needed to reformat the titles for certain songs. The audio recognition API returned some song titles with superfluous information, such as "(Taylor's Version)" or "(feat. Lana Del Rey)," which are indeed useful but aren't recognized by Swiftle, as a human user would likely have trouble distinguishing these. This was a simple fix, as I just needed to remove anything from the titles contained in parentheses.</p>
  
      <pre><code class="language-python">def clean_title(title):
    return re.sub(r"\s*\(.*?\)", "", title).strip()</code></pre>
  
      <p>Finally, I proceeded with programming the keyboard commands via AppleScript and cliclick.</p>
  
      <pre><code class="language-python">def submit_song(song_title):
    clean = clean_title(song_title)
    x, y = SEARCH_BAR_COORDS
    apple_script = f'''
    do shell script "cliclick m:{x},{y} c:{x},{y}"
    delay 0.3
    tell application "System Events"
        keystroke "{clean}"
        delay 0.4
        key code 125 -- down arrow
        delay 0.1
        key code 36  -- return key
    end tell
    '''</code></pre>

      
      <h2>Future Improvements</h2>
  
      <p>Thereâ€™s a lot of room to build on this project, both in polish and in ambition. One improvement would be to transition from static recording to real-time or on-the-spot recognition; ideally, the system could start listening as soon as Swiftle plays and identify the track without needing to save a snippet. This could open the door to using speech-to-text or humming-based recognition, especially for games or variants where the snippet isn't cleanly isolated. Moreover, creating a Taylor Swiftâ€“specific database rather than querying against every song ever released would significantly speed up recognition and reduce false positives. </p>
  
      <p>On a practical level, Iâ€™d like to add error handling, such as checking if the submitted answer matched the identified one, or retrying the request if the audio recognition API fails. While it currently works only with hardcoded screen positions, turning the whole thing into a GUI app with a start button and calibration step would make it easier to share.</p>
  
      <p>For now, the script functions well enough for it to beat the game. Which is good enough for me.</p>

      
      <h2>Closing Thoughts</h2>
  
      <p>Coding has never been more than a hobby to me, and I've only taken one coding class throughout high school. But I've always found it extremely interesting because of the sheer breadth of areas it can be applied to. During the pandemic, coding was my solace, and much like Taylor Swift, I made many friends because of a shared interest in it. As I've gotten older, I've had less and less free time to pursue my ideas, so this was a much-needed re-entry back into the world of programming. It was also a chance to stitch together a few disparate pieces of knowledge: Python scripting, macOS automation, audio routing, and web APIs. Iâ€™ve always been a huge fan of applying programming to small personal quirks, dating back to middle school, when I coded a simulation for one of my favorite video games. I care about Taylor Swift trivia, and I care about automation. This project was a surprisingly elegant union of the two, and it really was something I'd dreamt of doing for a while, but never knew how to go about it.</p>
  
      <p>Also: it worked! I now beat my friends at Swiftle.</p>
    </div>
  </main>
  <footer>
    Â© 2025 Connor Huh. All rights reserved.
  </footer>
    <!-- JS scroll behavior -->
    <script>
    // Navbar hide-on-scroll behavior
    let lastScrollY = window.scrollY;
    const nav = document.querySelector('nav');
  
    window.addEventListener('scroll', () => {
      const currentScrollY = window.scrollY;
      if (currentScrollY > lastScrollY && currentScrollY > 50) {
        nav.classList.add('hidden');
      } else {
        nav.classList.remove('hidden');
      }
      lastScrollY = currentScrollY;
    });
  
    // Dark mode toggle handler
    const modeToggle = document.getElementById("mode-toggle");
    modeToggle.addEventListener("change", function () {
      document.body.classList.toggle("dark-mode");
    });
  </script>
</body>
</html>
