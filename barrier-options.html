<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connor Huh</title>
  <link rel="stylesheet" href="/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</head>
<body>
  <nav>
    <div class="nav-brand">Connor Huh</div>
  
    <div class="nav-right">
      <ul class="navbar">
        <li><a href="/">Home</a></li>
        <li><a href="/projects">Projects</a></li>
      </ul>
  
      <label class="theme-switch" for="mode-toggle">
        <input type="checkbox" id="mode-toggle" />
        <span class="slider"></span>
        <span class="emoji sun">‚òÄÔ∏è</span>
        <span class="emoji moon">üåô</span>
      </label>
    </div>
  </nav>
  <header>
    <h1>A Simulation Approach to Pricing Foreign Exchange Barrier Options</h1>
  </header>
</body>
  <main>
    <div class="content">
      <h2>Introduction</h2>
      <p>
      Barrier options sit at the intersection of elegant theory and messy implementation. These exotic derivatives are path-dependent ‚Äî meaning their payoff depends not just on the final price of the underlying, but also on whether certain ‚Äúbarriers‚Äù were touched along the way. This nuance makes them tricky to price with traditional closed-form solutions like Black-Scholes. 
      </p>
      
      <p>
      In this project, I explored a <strong>Monte Carlo simulation method</strong> for pricing <em>foreign exchange (FX) up-and-out call options</em>. My goal was to replicate the pricing behavior of real-world barrier options using random sampling techniques and continuous-time Brownian motion ‚Äî and to better understand why reflective conditions and discretization errors make this such a rich area for modeling.
      </p>
      
      <h2>Why Simulation?</h2>
      
      <p>
      While closed-form solutions do exist for some simple barrier cases, they quickly become unwieldy in realistic FX environments. Simulation provides more flexibility: we can model arbitrary paths, fine-tune assumptions, and observe empirical convergence behavior.
      </p>
      
      <p>
      The idea is simple in principle: simulate many potential price paths of the underlying currency pair, check whether the barrier was breached for each path, and calculate the discounted payoff accordingly. Then, average over all the valid (i.e., not knocked-out) paths to estimate the option value.
      </p>
      
      <h2>Modeling Assumptions</h2>
      
      <ul>
        <li>The spot FX rate follows a geometric Brownian motion</li>
        <li>Volatility and interest rates are constant (though stochastic volatility extensions are possible)</li>
        <li>The option has a European-style payoff with a single barrier (up-and-out)</li>
      </ul>
      
      <p>
      Paths are discretized using the standard Euler-Maruyama method. A reflective boundary condition is applied: if the simulated spot price crosses the barrier at any step, the option is considered worthless for that path.
      </p>
      
      <h2>Core Pricing Logic</h2>
      
      <p>
      At the heart of the implementation is a loop over Monte Carlo paths. For each simulated path, the algorithm checks whether the barrier was touched. If not, the terminal value is used to compute the payoff of a vanilla call option.
      </p>
      
      <pre><code class="language-python">for i in range(N):
          path = simulate_path(S0, r, sigma, T, steps)
          if np.max(path) &gt;= barrier:
              continue  # knocked out
          payoff_sum += max(path[-1] - K, 0)</code></pre>
      
      <p>
      The final price is then computed as:
      </p>
      
      <pre><code class="language-python">option_price = np.exp(-r * T) * (payoff_sum / N)</code></pre>
      
      <p>
      Simple as it looks, the challenge lies in tuning <code>N</code> (number of paths), <code>steps</code> (time granularity), and dealing with variance reduction and convergence.
      </p>
      
      <h2>Validation and Convergence</h2>
      
      <p>
      To test the accuracy of the simulation, I compared results to the analytical formula derived by Reiner and Rubinstein. While analytical solutions have their own assumptions, they offer a reasonable benchmark for Monte Carlo outputs.
      </p>
      
      <p>
      As expected, increasing the number of simulations led to better accuracy and stability. Beyond a certain threshold, however, variance reductions offered diminishing returns ‚Äî a phenomenon consistent with the <em>law of large numbers</em> and the square-root convergence rate of Monte Carlo estimators.
      </p>
      
      <h2>Reflections</h2>
      
      <p>
      This project helped me build a deeper understanding of path-dependent options and why they‚Äôre hard to model in practice. It also reminded me how much of mathematical modeling is about tradeoffs: resolution vs. runtime, precision vs. interpretability, and elegance vs. flexibility.
      </p>
      
      <!-- INSERT YOUR REFLECTION HERE -->
      <p><em>[Insert a short paragraph here about your learning experience. For example: what confused you at first, what you enjoyed solving, or what surprised you in the process.]</em></p>
      
      <h2>Future Directions</h2>
      
      <p>
      There‚Äôs a lot of room for future improvement here. For example:
      </p>
      <ul>
        <li>Modeling stochastic volatility (e.g., Heston model)</li>
        <li>Adaptive time-stepping to better capture barrier crossings</li>
        <li>Implementing antithetic variates or control variates for faster convergence</li>
        <li>Testing double barrier options or touch options</li>
        <li>Using GPU acceleration for simulating large batches of paths in parallel</li>
      </ul>
      
      <p>
      More ambitiously, it would be interesting to use machine learning as a surrogate model: train a neural net to approximate the option price surface from a large simulation dataset, enabling fast approximations with minimal computational cost.
      </p>
      
      <h2>Closing Thoughts</h2>
      
      <p>
      This paper began as a curiosity about FX options and ended up being a satisfying mix of stochastic calculus, simulation, and financial modeling. Writing this code helped me appreciate how much nuance hides behind "just simulate some paths" ‚Äî and why barrier options are often left to quants and not retail traders.
      </p>
      
      <p>
      If you're interested in the full implementation, feel free to check out the code repository and notebook breakdown.
      </p>

    </div>
  </main>
  <footer>
    ¬© 2025 Connor Huh. All rights reserved.
  </footer>
  <!-- JS scroll behavior -->
  <script>
    let lastScrollY = window.scrollY;
    const nav = document.querySelector('nav');
  
    window.addEventListener('scroll', () => {
      const currentScrollY = window.scrollY;
      if (currentScrollY > lastScrollY && currentScrollY > 50) {
        nav.classList.add('hidden');
      } else {
        nav.classList.remove('hidden');
      }
      lastScrollY = currentScrollY;
    });
  
    // Dark mode toggle
    const modeToggle = document.getElementById("mode-toggle");
    const body = document.body;
  
    // On load, set toggle position to current theme
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      body.classList.add('dark');
      modeToggle.checked = true;
    } else {
      body.classList.remove('dark');
      modeToggle.checked = false;
    }
  
    modeToggle.addEventListener("change", function () {
      if (this.checked) {
        body.classList.add('dark');
        localStorage.setItem('theme', 'dark');
      } else {
        body.classList.remove('dark');
        localStorage.setItem('theme', 'light');
      }
    });
  </script>
</body>
</html>
